#!/usr/bin/env bash
# Create a new agent with basic scaffolding

. "$(dirname "$0")/init"

# Function to echo (can be silenced)
echoh() {
    if [ "${SILENT_OUTPUT:-}" != "true" ]; then
        echo "$@"
    fi
}

# Function to convert kebab-case to snake_case
kebab_to_snake() {
    echo "$1" | sed 's/-/_/g'
}

# Function to convert kebab-case to PascalCase
kebab_to_pascal() {
    echo "$1" | sed 's/-/ /g' | sed 's/\b\w/\U&/g' | sed 's/ //g'
}

# Function to create agent file
create_agent_file() {
    local agent_name="$1"
    local agent_description="$2"
    local agent_mode="$3"
    local snake_name=$(kebab_to_snake "$agent_name")
    local pascal_name=$(kebab_to_pascal "$agent_name")
    local agent_file="src/backend/agents/${snake_name}_agent.py"

    if [ -f "$agent_file" ]; then
        echoh "üìÑ Agent file already exists: $agent_file"
        return 1
    fi

    # Ensure directory exists
    mkdir -p "$(dirname "$agent_file")"

    if [ "$agent_mode" = "flow" ]; then
        cat > "$agent_file" << EOF
"""
${pascal_name} agent using Opper SDK in flow mode.

${agent_description}
"""

from pydantic import BaseModel, Field
from opper_agent import Agent, step, Workflow, ExecutionContext


# Input/Output models for the workflow
class ${pascal_name}Request(BaseModel):
    goal: str = Field(description="The main goal or task to accomplish")
    # Add more fields as needed for your agent


class ${pascal_name}Result(BaseModel):
    result: str = Field(description="The final result")
    summary: str = Field(description="Summary of what was accomplished")
    # Add more fields as needed for your output


# Workflow steps
@step
async def process_request(request: ${pascal_name}Request, ctx: ExecutionContext) -> ${pascal_name}Result:
    """Process the main request using AI reasoning."""
    try:
        # Use the LLM to process the request
        result = await ctx.llm(
            name="${snake_name}_processor",
            instructions=(
                "Process this request and provide a helpful response. "
                "${agent_description}"
            ),
            input_schema=${pascal_name}Request,
            output_schema=${pascal_name}Result,
            input=request,
        )

        # Opper API returns dict, convert to Pydantic model
        if isinstance(result, dict):
            result = ${pascal_name}Result.model_validate(result)

        return result
    except Exception as e:
        # Fallback response
        return ${pascal_name}Result(
            result=f"Error processing request: {str(e)}",
            summary="Request could not be processed due to an error"
        )


def create_${snake_name}_workflow():
    """Create the workflow for the ${agent_name} agent."""
    return (
        Workflow(
            id="${agent_name}-workflow",
            input_model=${pascal_name}Request,
            output_model=${pascal_name}Result
        )
        .then(process_request)
        .commit()
    )


def get_${snake_name}_agent():
    """
    Create the ${agent_name} agent.

    ${agent_description}
    """
    workflow = create_${snake_name}_workflow()
    return Agent(
        name="${agent_name}",
        description="${agent_description}",
        flow=workflow,
        verbose=True
    )
EOF
    else  # tools mode
        cat > "$agent_file" << EOF
"""
${pascal_name} agent using Opper SDK in tools mode.

${agent_description}
"""

from opper_agent import Agent, tool


# IMPORTANT: Tools decorated with @tool are called by the Opper agent, not by your code!
# - Each tool should do ONE specific task
# - Tools CANNOT call other @tool decorated functions directly
# - The agent handles orchestration - it decides which tools to call and in what order
# - If you need a high-level orchestration function, that's what the agent itself does!

@tool
def example_tool(input_text: str) -> str:
    """
    An example tool for the ${agent_name} agent.

    Args:
        input_text: Text to process

    Returns:
        Processed result
    """
    # Add your tool logic here
    # This should be self-contained - don't call other @tool functions
    return f"Processed: {input_text}"


# Add more tools as needed for your agent
@tool
def another_tool(value: int) -> str:
    """
    Another example tool.

    Args:
        value: A number to process

    Returns:
        String result
    """
    # Add your tool logic here
    return f"Result: {value * 2}"


def get_${snake_name}_agent():
    """
    Create the ${agent_name} agent.

    ${agent_description}
    """
    return Agent(
        name="${agent_name}",
        description="${agent_description}",
        tools=[example_tool, another_tool],
        instructions="""You are a helpful AI assistant. Describe what this agent does and how to use it.""",  # Optional: custom instructions for the agent
        verbose=True  # Set to False to reduce output
    )
EOF
    fi

    echoh "‚úÖ Created agent file: $agent_file"
    return 0
}

# Function to update agents __init__.py
update_agents_init() {
    local agent_name="$1"
    local snake_name=$(kebab_to_snake "$agent_name")
    local init_file="src/backend/agents/__init__.py"

    # Check if import already exists
    if grep -q "from .${snake_name}_agent import get_${snake_name}_agent" "$init_file" 2>/dev/null; then
        echoh "‚ö†Ô∏è  Agent import already exists in $init_file"
        return 0
    fi

    # Use awk to robustly update the file
    local temp_file=$(mktemp)
    local import_line="from .${snake_name}_agent import get_${snake_name}_agent"
    local export_name="get_${snake_name}_agent"
    local agent_entry="    (\"${agent_name}\", get_${snake_name}_agent),"

    awk -v import_line="$import_line" -v export_name="$export_name" -v agent_entry="$agent_entry" '
    BEGIN {
        import_added = 0
        in_agents_section = 0
        in_all_section = 0
        line_num = 0
    }

    {
        line_num++
    }

    # Add import after existing imports or at the very beginning
    /^from \..*_agent import/ && !import_added {
        print $0
        print import_line
        import_added = 1
        next
    }

    # If first line and no imports yet, add import at top
    line_num == 1 && !import_added && !/^from \..*_agent import/ {
        print import_line
        print $0
        import_added = 1
        next
    }

    # Update AGENTS list
    /^AGENTS = \[/ {
        in_agents_section = 1
        print $0
        next
    }

    # Add agent entry before closing bracket of AGENTS
    in_agents_section && /^\]$/ {
        print agent_entry
        print $0
        in_agents_section = 0
        next
    }

    # Update __all__ list
    /^__all__ = \[/ {
        in_all_section = 1
        # Replace the line with updated __all__
        gsub(/\]$/, ", \"" export_name "\"]")
        print $0
        next
    }

    # Handle multi-line __all__ (if it exists)
    in_all_section && /\]/ {
        gsub(/\]/, ", \"" export_name "\"]")
        print $0
        in_all_section = 0
        next
    }

    # Print all other lines as-is
    { print $0 }
    ' "$init_file" > "$temp_file"

    # Replace original file
    mv "$temp_file" "$init_file"
    echoh "‚úÖ Updated $init_file with new agent import"
}

# Function to show registration note
add_registration_note() {
    local agent_name="$1"

    echoh ""
    echoh "‚úÖ Agent has been automatically registered!"
    echoh "The agent will be available when the server starts."
    echoh ""
}

# Function to show completion message
show_completion() {
    local agent_name="$1"
    local agent_file="$2"
    local snake_name=$(kebab_to_snake "$agent_name")

    echoh ""
    echoh "üéâ Agent scaffolded successfully!"
    echoh ""
    echoh "üìÅ Agent file: $agent_file"
    echoh "üîß Agent function: get_${snake_name}_agent()"
    echoh ""
    echoh "Next steps:"
    echoh "1. Edit $agent_file to implement your agent logic"
    echoh "2. Create test scripts: bin/add-script test-${agent_name}"
    echoh "3. Test via API: POST /api/v1/agents/${agent_name}/calls"
}

# Main logic
main() {
    # Check if agent name was provided
    if [ $# -lt 1 ]; then
        echoh "Usage: bin/add-agent <agent-name> [description] [mode]"
        echoh "  agent-name: kebab-case name (e.g., 'my-research-agent')"
        echoh "  description: Optional description of what the agent does"
        echoh "  mode: 'tools' or 'flow' (default: tools)"
        echoh ""
        echoh "Example: bin/add-agent research-assistant \"Helps with research tasks\" flow"
        exit 1
    fi

    AGENT_NAME="$1"
    AGENT_DESCRIPTION="${2:-An AI agent that helps with various tasks}"
    AGENT_MODE="${3:-tools}"
    SNAKE_NAME=$(kebab_to_snake "$AGENT_NAME")
    AGENT_FILE="src/backend/agents/${SNAKE_NAME}_agent.py"

    # Validate agent mode
    if [ "$AGENT_MODE" != "tools" ] && [ "$AGENT_MODE" != "flow" ]; then
        echoh "‚ùå Invalid mode: $AGENT_MODE. Must be 'tools' or 'flow'"
        exit 1
    fi

    # Check if flow mode components are available
    if [ "$AGENT_MODE" = "flow" ]; then
        if ! python3 -c "from opper_agent import step, Workflow, ExecutionContext" 2>/dev/null; then
            echoh "‚ö†Ô∏è  Flow mode is not yet available in the current SDK."
            echoh "   Using tools mode instead."
            AGENT_MODE="tools"
        fi
    fi

    # Validate agent name format
    if ! echo "$AGENT_NAME" | grep -q '^[a-z][a-z0-9-]*[a-z0-9]$\|^[a-z]$'; then
        echoh "‚ùå Invalid agent name format. Use kebab-case (e.g., 'my-agent', 'research-helper')"
        exit 1
    fi

    echoh "Creating ${AGENT_MODE}-mode agent: $AGENT_NAME"
    echoh "Description: $AGENT_DESCRIPTION"

    # Create agent file
    create_agent_file "$AGENT_NAME" "$AGENT_DESCRIPTION" "$AGENT_MODE"

    # Update __init__.py
    update_agents_init "$AGENT_NAME"

    # Show registration note
    add_registration_note "$AGENT_NAME"

    # Show completion message
    show_completion "$AGENT_NAME" "$AGENT_FILE"
}

main "$@"